# 1.0 Runtime Semantics — Deterministic Agent Runtime

本文档描述 Aetheris 1.0 的**最小运行时语义**：从「可恢复的 agent」升级为「可信执行的 agent」—— Replay 不再触发真实外部调用，且当外部世界与记录不一致时可拒绝信任已提交结果。

## 目标

- **Execution replay（旧）**：程序恢复到某一步，但现实世界可能已被再次修改。
- **World-consistent replay（1.0）**：Event → 校验外部世界 → 恢复内存 → 跳过执行（Execution Permission）。

实现该闭环需要三个机制，均在代码中已实现；本文档说明语义并指向关键文件。

---

## ① Tool Invocation Ledger（工具调用账本）

**语义**：Runner **不拥有**执行权；执行权由 Ledger 裁决。每次 tool 步：Runner 调用 `InvocationLedger.Acquire(...)`；Ledger 返回 `AllowExecute`（无已提交记录）或 `ReturnRecordedResult`（已有 committed 成功记录）。仅当 `AllowExecute` 时 Runner 执行 tool 并调用 `Commit`；`ReturnRecordedResult` 时只做 Confirmation 后注入结果、**禁止调用 tool**。Replay = 查账本/事件恢复结果，不执行代码。

**关键文件**：

- [internal/agent/runtime/executor/ledger.go](internal/agent/runtime/executor/ledger.go)：`InvocationLedger` 接口（`Acquire`、`Commit`、`Recover`）与 `InvocationDecision`（AllowExecute、ReturnRecordedResult、WaitOtherWorker、Rejected）。
- [internal/agent/runtime/executor/ledger_store.go](internal/agent/runtime/executor/ledger_store.go)：基于 `ToolInvocationStore` 的 Ledger 实现；Acquire 内查 store 或使用 replay 注入的 `replayResult`。
- [internal/agent/runtime/executor/invocation_store.go](internal/agent/runtime/executor/invocation_store.go)：`ToolInvocationRecord`、`ToolInvocationStore`（GetByJobAndIdempotencyKey、SetStarted、SetFinished）。
- [internal/agent/runtime/executor/node_adapter.go](internal/agent/runtime/executor/node_adapter.go)：当 `InvocationLedger != nil` 时，先 `Acquire`；若 `ReturnRecordedResult` 则 Confirmation + 注入并 return；若 `AllowExecute` 则执行 tool 后 `Commit`。无 Ledger 时保留兼容路径（直接查 Store / CompletedToolInvocations）。
- [internal/agent/replay/replay.go](internal/agent/replay/replay.go)：`tool_invocation_finished`（outcome success）→ `CompletedToolInvocations[idempotency_key] = result`，Replay 时将结果注入 context，Adapter 的 Acquire 收到 `replayResult` 即返回 `ReturnRecordedResult`。

**结论**：当存在已提交成功记录（Ledger/Store 或事件构建的 CompletedToolInvocations）时，replay **不会**触发真实 tool 调用。

**多 Worker**：多 Worker 需共享 `ToolInvocationStore`（如 PostgreSQL）。Ledger 实现包装该 Store；同一 idempotency_key 仅允许一次 Commit。可选实现见 [internal/agent/runtime/executor/invocation_pg.go](internal/agent/runtime/executor/invocation_pg.go)。

---

## ② StepOutcome 世界语义

**语义**：Step 结果不仅表示「程序是否成功」，还表示「世界是否被改变」。只有 **Pure** 步在 Replay 时可安全重放执行；**SideEffectCommitted** 步只能恢复结果，禁止再次执行。Replay 与 Scheduler 根据 outcome 决定是否重试、是否视为完成。

**结果类型（世界语义）**：

| 类型 | 含义 |
|------|------|
| pure | 无副作用完成（纯计算，如 LLM 步）；Replay 可重放执行 |
| success | 通用成功（内部用；非 tool 步会记为 pure） |
| side_effect_committed | 外部世界已改变（tool 步成功）；Replay 仅恢复结果，禁止再执行 |
| retryable_failure | 可重试 |
| permanent_failure | 逻辑失败 |
| compensatable_failure | 部分提交，待补偿 |
| compensated | 已回滚，视为终态 |

**关键文件**：

- [internal/agent/runtime/executor/runner.go](internal/agent/runtime/executor/runner.go)：`StepResultPure`、`StepResultSideEffectCommitted`、`StepResultCompensated` 等；成功 **非 tool** 步记为 `pure`，成功 **tool** 步记为 `side_effect_committed`。
- [internal/agent/replay/replay.go](internal/agent/replay/replay.go)：`result_type` 为 `""`、`success`、`pure`、`side_effect_committed`、`compensated` 时节点视为完成。
- [internal/agent/job/scheduler.go](internal/agent/job/scheduler.go)：不对 `SideEffectCommitted`、`Compensated` 重试。

TraceUI 与事件流可将 `pure` 视为「无世界变更」、`side_effect_committed` 视为「外部世界已改变」用于审计。

---

## ③ Confirmation Replay（确认式重放）

**语义**：Replay 不是「再执行一次 step」，而是「加载事件 → 重建状态 → 查账本 → 有记录则恢复输出，无记录则执行 step」。**已提交副作用的 step 禁止再次执行**（Runner 必须跳过执行，仅恢复结果）。

**Replay 流程（Confirmation Replay）**：

1. **加载事件**：从 JobStore 拉取该 job 的完整事件流（PlanGenerated、NodeFinished、tool_invocation_*、state_changed、command_committed 等）。
2. **重建状态**：`ReplayContextBuilder.BuildFromEvents` 得到 `ReplayContext`（TaskGraphState、CompletedNodeIDs、CompletedToolInvocations、StateChangesByStep、PayloadResults 等）。
3. **Runner 注入**：Runner 在 `replayCtx != nil` 时，将 `CompletedToolInvocations` 与 `StateChangesByStep` 注入 context，再对未完成节点调用 `step.Run`。
4. **Tool 步裁决**：对每个 tool 节点，Adapter 调用 `InvocationLedger.Acquire(..., replayResult)`，其中 `replayResult = CompletedToolInvocations[idempotencyKey]`（来自事件流）或 Ledger/Store 中已提交记录。
   - **有记录**（`ReturnRecordedResult`）：执行 `runConfirmation`（ResourceVerifier + StateChangesByStep）；通过则注入结果并 **return，不调用 tool**；不通过则 job 永久失败。
   - **无记录**（`AllowExecute`）：执行 tool，成功后 `Commit`，再写事件。
5. **禁止重放已提交副作用**：任一 code path 在「已有 committed 成功记录」时都 **不得** 再次调用 `Tools.Execute`；仅允许注入已记录结果。Ledger 是唯一仲裁者。

**审计要点**：确保不存在「在已 Commit 或已 ReturnRecordedResult 的情况下仍执行 tool」的路径。当前实现中，Adapter 仅在 `InvocationDecisionAllowExecute` 分支调用 `runNodeExecute`（内部才执行 tool）；`ReturnRecordedResult` 分支仅做 Confirmation + 注入后 return。无 Ledger 时，先查 Store/CompletedToolInvocations，命中则注入并 return，未命中才执行。

**关键文件**：

- [internal/agent/runtime/executor/state_diff.go](internal/agent/runtime/executor/state_diff.go)：`ResourceVerifier` 接口；`StateChanged` 含 Version、Etag、ExternalRef 供审计与校验。
- [internal/agent/replay/replay.go](internal/agent/replay/replay.go)：`BuildFromEvents` 构建 ReplayContext；`state_changed` → `StateChangesByStep`；`tool_invocation_finished`（success）→ `CompletedToolInvocations`。
- [internal/agent/runtime/executor/runner.go](internal/agent/runtime/executor/runner.go)：`replayCtx != nil` 时注入 `CompletedToolInvocations` 与 `StateChangesByStep`，再 `step.Run`。
- [internal/agent/runtime/executor/node_adapter.go](internal/agent/runtime/executor/node_adapter.go)：Ledger 路径下 `Acquire` → `ReturnRecordedResult` 则 Confirmation + 注入并 return；`AllowExecute` 则 `runNodeExecute`（唯一执行 tool 的路径）。注入前统一 `runConfirmation`。

**结论**：Replay = 查账本/事件恢复结果，有记录则恢复、无记录则执行；**永不**对已提交的 tool 步再执行一次。

**生产**：应用与 Worker 当前传入 `resourceVerifier = nil`，因此默认不执行具体校验。需至少一个具体 `ResourceVerifier` 实现并在 bootstrap 中挂载，才能使「校验外部世界」非 no-op。见 [internal/agent/runtime/executor/verifier/github.go](internal/agent/runtime/executor/verifier/github.go)。

---

## 小结

| 机制 | 语义 | 实现位置 |
|------|------|----------|
| ① Tool Invocation Ledger | Ledger 裁决；Acquire/Commit；提交后 replay 仅恢复不执行 | ledger.go, ledger_store.go, node_adapter.go, replay.go |
| ② StepOutcome 世界语义 | pure / side_effect_committed / compensated 等；仅 Pure 可重放执行 | runner.go, replay.go, scheduler.go |
| ③ Confirmation Replay | 加载事件 → 重建 → 查账本 → 有记录恢复、无记录执行；永不重放已提交副作用 | replay.go, runner.go, node_adapter.go, state_diff.go |

完成上述三点后，Aetheris 具备**最小运行时语义**：replay 不再触发外部调用，且当外部世界与记录不一致时可拒绝信任已提交结果，即「可信执行的 agent」而非仅「可恢复的 agent」。
