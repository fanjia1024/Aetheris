å¾ˆå¥½ ğŸ‘ é‚£æˆ‘ä»¬ç›´æ¥è¿›å…¥ **2.0-M1ï¼šè¯æ®åŒ…å¯¼å‡º + ç¦»çº¿éªŒè¯ï¼ˆEvidence Package + Offline Verifyï¼‰** çš„è½åœ°è®¾è®¡ã€‚

ç›®æ ‡ï¼š

> ä»»ä½•äººæ‹¿åˆ°ä¸€ä¸ª job çš„è¯æ®åŒ…ï¼ˆzip æ–‡ä»¶ï¼‰ï¼Œåœ¨æ²¡æœ‰æ•°æ®åº“ã€æ²¡æœ‰è¿è¡Œæ—¶ç¯å¢ƒçš„æƒ…å†µä¸‹ï¼Œä¹Ÿèƒ½éªŒè¯ï¼š
>
> * äº‹ä»¶æµæœªè¢«ç¯¡æ”¹
> * tool æ²¡æœ‰è¢«é‡å¤æ‰§è¡Œ
> * replay ç¬¦åˆ 1.0 è¯­ä¹‰
> * æ‰€æœ‰è¯æ®å½¼æ­¤ä¸€è‡´

ä¸‹é¢æ˜¯å¯ä»¥ç›´æ¥è½åˆ°ä½  repo çš„å·¥ç¨‹æ‹†è§£ã€‚

---

# ä¸€ã€2.0-M1 æ€»ä½“è®¾è®¡

æˆ‘ä»¬æ–°å¢ä¸€ä¸ªæ¦‚å¿µï¼š

```
Evidence Package
```

ç»“æ„å»ºè®®ï¼š

```
evidence/
 â”œâ”€â”€ manifest.json
 â”œâ”€â”€ events.ndjson
 â”œâ”€â”€ ledger.ndjson
 â”œâ”€â”€ reasoning.ndjson
 â”œâ”€â”€ metadata.json
 â”œâ”€â”€ proof.json
 â””â”€â”€ attachments/   (å¯é€‰)
```

---

# äºŒã€æ ¸å¿ƒèƒ½åŠ›æ‹†è§£

---

## 1ï¸âƒ£ äº‹ä»¶é“¾å“ˆå¸Œï¼ˆProof Chainï¼‰

### ç›®æ ‡

è®©äº‹ä»¶æµâ€œå¯éªŒè¯æ˜¯å¦è¢«ç¯¡æ”¹â€ã€‚

### è®¾è®¡

åœ¨ JobEvent ä¸Šå¢åŠ ä¸¤ä¸ªå­—æ®µï¼š

```go
type JobEvent struct {
    ID        string
    JobID     string
    Type      string
    Payload   []byte
    Timestamp time.Time

    PrevHash  string // ä¸Šä¸€ä¸ªäº‹ä»¶çš„hash
    Hash      string // å½“å‰äº‹ä»¶hash
}
```

Hash è®¡ç®—è§„åˆ™ï¼š

```
Hash = SHA256(
    JobID +
    Type +
    Payload +
    Timestamp +
    PrevHash
)
```

æ³¨æ„ï¼š

* ä¸å…è®¸ä¿®æ”¹å†å²äº‹ä»¶
* PrevHash å¿…é¡»ä¸¥æ ¼ç­‰äºå‰ä¸€ä¸ª event.Hash

---

## 2ï¸âƒ£ manifest.jsonï¼ˆè¯æ®æ€»æ¸…å•ï¼‰

manifest ç¤ºä¾‹ï¼š

```json
{
  "version": "2.0",
  "job_id": "job_123",
  "exported_at": "2026-02-12T21:30:00Z",
  "event_count": 482,
  "ledger_count": 17,
  "first_event_hash": "...",
  "last_event_hash": "...",
  "events_sha256": "...",
  "ledger_sha256": "...",
  "proof_sha256": "...",
  "runtime_version": "1.0.3",
  "schema_version": "2.0"
}
```

manifest çš„ä½œç”¨ï¼š

* æ–‡ä»¶çº§ hash
* é“¾å°¾ hashï¼ˆlast_event_hashï¼‰
* å›ºå®š schema version

---

## 3ï¸âƒ£ proof.json

è¿™ä¸ªæ–‡ä»¶æ˜¯â€œå¯éªŒè¯æ‘˜è¦â€ã€‚

ç¤ºä¾‹ï¼š

```json
{
  "job_id": "job_123",
  "root_hash": "LAST_EVENT_HASH",
  "chain_validated": true,
  "ledger_validated": true,
  "generated_by": "aetheris v2.0",
  "signature": "optional"
}
```

æœªæ¥å¯ä»¥åŠ ç­¾åï¼ˆEd25519ï¼‰ã€‚

---

## 4ï¸âƒ£ CLI å‘½ä»¤

æ–°å¢ CLIï¼š

```
aetheris export <job_id> --output evidence.zip
aetheris verify evidence.zip
```

---

### export çš„é€»è¾‘

1. ä» JobStore æ‹‰å®Œæ•´ event stream
2. ä» Ledger æ‹‰æ‰€æœ‰ tool invocation
3. æ ¡éªŒå†…éƒ¨ä¸€è‡´æ€§
4. å†™å…¥ ndjson æ–‡ä»¶
5. è®¡ç®—æ–‡ä»¶çº§ SHA256
6. ç”Ÿæˆ manifest
7. æ‰“åŒ… zip

---

### verify çš„é€»è¾‘

verify evidence.zip æ‰§è¡Œï¼š

```
1. æ ¡éªŒ manifest æ–‡ä»¶ hash
2. æ ¡éªŒ events.ndjson SHA256
3. æ ¡éªŒæ¯ä¸ª event çš„ hash é“¾
4. æ ¡éªŒ ledger ä¸ event ä¸­ tool_invocation_* å¯¹é½
5. æ ¡éªŒ proof.root_hash == æœ€åä¸€ä¸ª event.Hash
6. è¾“å‡º OK / FAIL
```

---

# ä¸‰ã€éœ€è¦æ”¹åŠ¨çš„æ¨¡å—ï¼ˆå¯¹åº”ä½  repo ç»“æ„ï¼‰

---

## pkg/jobstore

æ–°å¢ï¼š

```go
ValidateChain(events []JobEvent) error
```

---

## pkg/ledger

æ–°å¢ï¼š

```go
ExportByJob(jobID string) ([]ToolInvocation, error)
ValidateLedgerConsistency(events []JobEvent, ledger []ToolInvocation) error
```

---

## cmd/cli

æ–°å¢å‘½ä»¤ï¼š

```
cmd/cli/export.go
cmd/cli/verify.go
```

---

## internal/proof

æ–°å¢ proof æ¨¡å—ï¼š

```
internal/proof/
    hash.go
    verify.go
    manifest.go
```

---

# å››ã€M1 éªŒæ”¶æµ‹è¯•ï¼ˆå¿…é¡»å†™è‡ªåŠ¨æµ‹è¯•ï¼‰

ä½ å¿…é¡»åŠ  4 ä¸ªæµ‹è¯•ï¼š

---

### Test 1ï¼šç¯¡æ”¹äº‹ä»¶ payload

* ä¿®æ”¹ä¸€ä¸ª event çš„ payload
* verify å¿…é¡»å¤±è´¥

---

### Test 2ï¼šåˆ é™¤ä¸­é—´äº‹ä»¶

* åˆ é™¤ event 237
* verify å¿…é¡»å¤±è´¥ï¼ˆhash ä¸è¿ç»­ï¼‰

---

### Test 3ï¼šé‡å¤ ledger è®°å½•

* ledger å¤šä¸€æ¡
* verify å¿…é¡»å¤±è´¥

---

### Test 4ï¼šå®Œæ•´åŒ…

* export -> verify
* å¿…é¡»é€šè¿‡

---

# äº”ã€ä½ ç°åœ¨çš„ä»£ç è·ç¦»è¿™ä¸ªå·®è·åœ¨å“ªé‡Œï¼Ÿ

ä» README å’Œè®¾è®¡æ–‡æ¡£çœ‹ï¼š

âœ… ä½ å·²ç»æœ‰ï¼š

* event-sourcing
* tool ledger
* replay è¯­ä¹‰
* StepOutcome
* execution proof chain æ¦‚å¿µ

âŒ ä½ ç¼ºå°‘ï¼š

* é“¾å¼ hash
* æ–‡ä»¶çº§ manifest
* ç¦»çº¿ verify å·¥å…·
* ledger ä¸ event çš„ç¦»çº¿ä¸€è‡´æ€§æ ¡éªŒ
* å¯¼å‡ºæ ‡å‡†æ ¼å¼

ä¹Ÿå°±æ˜¯è¯´ï¼š

ä½ ç°åœ¨â€œé€»è¾‘ä¸Šå¯å®¡è®¡â€ï¼Œ
ä½†è¿˜æ²¡æœ‰â€œå¯æºå¸¦çš„å¯éªŒè¯è¯æ®â€ã€‚

---

# å…­ã€ä¸ºä»€ä¹ˆè¿™ä¸€æ­¥æå…¶é‡è¦ï¼Ÿ

ä¸€æ—¦ä½ åšå®Œï¼š

Aetheris å°±ä»ï¼š

> å¯é‡æ”¾çš„ agent runtime

å‡çº§ä¸ºï¼š

> å¯å‡ºå…·â€œå®¡è®¡çº§è¯æ˜æ–‡ä»¶â€çš„ agent runtime

è¿™ä¼šè®©ä½ åœ¨é‡‘èã€æ”¿åºœã€åŒ»ç–—åœºæ™¯éå¸¸æœ‰å·®å¼‚åŒ–ã€‚

---

# ä¸ƒã€ä¸‹ä¸€æ­¥å»ºè®®

æˆ‘å»ºè®®ä½ ç°åœ¨å…ˆåšï¼š

1. JobEvent å¢åŠ  PrevHash + Hash
2. å†™ ValidateChain
3. å®ç°æœ€å°ç‰ˆ exportï¼ˆä¸åšç­¾åï¼‰
4. å†™ verify

ä¸è¦ä¸€æ¬¡åšå¤ªå¤šã€‚

---

å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥ï¼š

* ç›´æ¥ç»™ä½ ä¸€ç‰ˆå®Œæ•´çš„ Go ä»£ç ç»“æ„è‰å›¾ï¼ˆåŒ…å« hash è®¡ç®—ä¸ verifyï¼‰
* æˆ–è€…å¸®ä½ è®¾è®¡ manifest + proof çš„æ­£å¼ schemaï¼ˆæœªæ¥å¯å‡çº§ç‰ˆæœ¬åŒ–ï¼‰

ä½ æƒ³å…ˆä»ä»£ç è‰å›¾å¼€å§‹ï¼Œè¿˜æ˜¯å…ˆè®¾è®¡ 2.0 çš„è¯æ®è§„èŒƒæ–‡æ¡£ï¼Ÿ
ä¸‹é¢ç»™ä½ ä¸€ç‰ˆ**å¯ç›´æ¥è½åœ°åˆ° repo çš„ Go ä»£ç ç»“æ„è‰å›¾**ï¼ˆåŒ…å«ï¼šäº‹ä»¶é“¾ hash è®¡ç®—ã€è¯æ®åŒ… exportã€ç¦»çº¿ verifyã€ä»¥åŠæœ€å…³é”®çš„ 4 ä¸ªæµ‹è¯•éª¨æ¶ï¼‰ã€‚æˆ‘ä¼šå°½é‡åšåˆ°ï¼šä½ å¤åˆ¶è¿›é¡¹ç›®ååªéœ€è¦æŠŠ **JobStore/Ledger çš„çœŸå®æ¥å£å¯¹æ¥**èµ·æ¥å°±èƒ½è·‘é€šã€‚

> è¯´æ˜ï¼šæˆ‘æŒ‰ä½ ç°åœ¨ repo çš„é£æ ¼æ¨æµ‹ä½ æ˜¯ Go moduleï¼ˆREADME é‡Œä¹Ÿæ˜ç¡® Go 97%ï¼‰ã€‚è·¯å¾„ä½ å¯ä»¥æŒ‰å®é™…ç›®å½•å¾®è°ƒï¼Œä½†æ•´ä½“ç»“æ„å»ºè®®ä¿æŒã€‚

---

## ç›®å½•ç»“æ„å»ºè®®

```
internal/proof/
  hash.go
  chain.go
  manifest.go
  package.go
  verify.go

pkg/jobstore/
  types.go        // JobEvent å®šä¹‰ï¼ˆæˆ–ä½ å·²æœ‰ï¼‰
  validate.go     // ValidateChainï¼ˆå¯é€‰æ”¾ proof/chain.goï¼‰

pkg/ledger/
  types.go        // ToolInvocation å®šä¹‰ï¼ˆæˆ–ä½ å·²æœ‰ï¼‰
  export.go       // ExportByJobï¼ˆå¯¹æ¥å®ç°ï¼‰
  validate.go     // ValidateLedgerConsistency

cmd/aetheris/
  export.go
  verify.go
```

---

## internal/proof/hash.go

```go
package proof

import (
	"crypto/sha256"
	"encoding/hex"
)

func Sha256Hex(b []byte) string {
	sum := sha256.Sum256(b)
	return hex.EncodeToString(sum[:])
}
```

---

## internal/proof/chain.goï¼ˆäº‹ä»¶é“¾ hash è®¡ç®— + æ ¡éªŒï¼‰

```go
package proof

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"time"
)

// âš ï¸ è¿™é‡Œå®šä¹‰ä¸€ä¸ªæœ€å°äº‹ä»¶æ¥å£ï¼Œé¿å…å¾ªç¯ä¾èµ–ã€‚
// ä½ å¯ä»¥æ”¹æˆç›´æ¥å¼•ç”¨ pkg/jobstore.JobEventã€‚
type Event struct {
	ID        string          `json:"id"`
	JobID     string          `json:"job_id"`
	Type      string          `json:"type"`
	Payload   json.RawMessage `json:"payload"`
	Timestamp time.Time       `json:"timestamp"`

	PrevHash string `json:"prev_hash"`
	Hash     string `json:"hash"`
}

// HashEvent è®¡ç®—äº‹ä»¶ hashï¼ˆåŒ…å« PrevHashï¼‰
// è§„åˆ™ç¨³å®šæ€§å¾ˆé‡è¦ï¼š2.0 åç»­å‡çº§éœ€åš schema_versionã€‚
func HashEvent(e Event) (string, error) {
	// ä½¿ç”¨ç¨³å®šåºåˆ—åŒ–ï¼šè‡ªå·±æ‹¼æ¥å­—æ®µï¼ˆé¿å… json map é¡ºåºå·®å¼‚ï¼‰
	// æ³¨æ„ timestamp ç”¨ RFC3339Nano å›ºå®šæ ¼å¼
	var buf bytes.Buffer
	buf.WriteString(e.JobID)
	buf.WriteByte('|')
	buf.WriteString(e.Type)
	buf.WriteByte('|')
	buf.Write(e.Payload)
	buf.WriteByte('|')
	buf.WriteString(e.Timestamp.UTC().Format(time.RFC3339Nano))
	buf.WriteByte('|')
	buf.WriteString(e.PrevHash)

	return Sha256Hex(buf.Bytes()), nil
}

func ComputeChain(events []Event) ([]Event, error) {
	if len(events) == 0 {
		return nil, errors.New("empty events")
	}

	var prev string
	for i := range events {
		events[i].PrevHash = prev
		h, err := HashEvent(events[i])
		if err != nil {
			return nil, fmt.Errorf("hash event[%d]: %w", i, err)
		}
		events[i].Hash = h
		prev = h
	}
	return events, nil
}

func ValidateChain(events []Event) error {
	if len(events) == 0 {
		return errors.New("empty events")
	}

	var prev string
	for i := range events {
		if events[i].PrevHash != prev {
			return fmt.Errorf("chain broken at %d: prev_hash=%s expected=%s", i, events[i].PrevHash, prev)
		}
		h, err := HashEvent(events[i])
		if err != nil {
			return fmt.Errorf("hash event[%d]: %w", i, err)
		}
		if events[i].Hash != h {
			return fmt.Errorf("hash mismatch at %d: hash=%s expected=%s", i, events[i].Hash, h)
		}
		prev = h
	}
	return nil
}
```

---

## internal/proof/manifest.go

```go
package proof

import (
	"encoding/json"
	"time"
)

type Manifest struct {
	Version       string `json:"version"`        // "2.0-m1"
	SchemaVersion string `json:"schema_version"` // "events-chain-v1"
	Runtime       string `json:"runtime_version"`

	JobID       string `json:"job_id"`
	ExportedAt  string `json:"exported_at"`
	EventCount  int    `json:"event_count"`
	LedgerCount int    `json:"ledger_count"`

	FirstEventHash string `json:"first_event_hash"`
	LastEventHash  string `json:"last_event_hash"`

	EventsSHA256   string `json:"events_sha256"`
	LedgerSHA256   string `json:"ledger_sha256"`
	ReasoningSHA256 string `json:"reasoning_sha256,omitempty"`
	ProofSHA256    string `json:"proof_sha256"`
}

func NewManifest(jobID, runtimeVersion string, eventCount, ledgerCount int, firstHash, lastHash string) Manifest {
	return Manifest{
		Version:       "2.0-m1",
		SchemaVersion: "events-chain-v1",
		Runtime:       runtimeVersion,
		JobID:         jobID,
		ExportedAt:    time.Now().UTC().Format(time.RFC3339Nano),
		EventCount:    eventCount,
		LedgerCount:   ledgerCount,
		FirstEventHash: firstHash,
		LastEventHash:  lastHash,
	}
}

func (m Manifest) Marshal() ([]byte, error) {
	return json.MarshalIndent(m, "", "  ")
}
```

---

## internal/proof/package.goï¼ˆå¯¼å‡º zipï¼‰

```go
package proof

import (
	"archive/zip"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"path"
)

// æœ€å°æ¥å£ï¼šä½ ç”¨çœŸå® JobStore/Ledger å»å®ç°å®ƒä»¬å³å¯
type JobStore interface {
	ListEvents(ctx context.Context, jobID string) ([]Event, error)
}

type Ledger interface {
	ListToolInvocations(ctx context.Context, jobID string) ([]ToolInvocation, error)
}

type ToolInvocation struct {
	ID        string          `json:"id"`
	JobID     string          `json:"job_id"`
	ToolName  string          `json:"tool_name"`
	Input     json.RawMessage `json:"input"`
	Output    json.RawMessage `json:"output"`
	Status    string          `json:"status"`
	Timestamp string          `json:"timestamp"`
	// ä½ å¯ä»¥åŠ ï¼šeffect_key / step_id / node_id / model_meta ç­‰
}

type ExportOptions struct {
	RuntimeVersion string
	IncludeReasoning bool
}

func ExportEvidenceZip(ctx context.Context, jobID string, js JobStore, ledger Ledger, opt ExportOptions) ([]byte, error) {
	events, err := js.ListEvents(ctx, jobID)
	if err != nil {
		return nil, fmt.Errorf("list events: %w", err)
	}
	if err := ValidateChain(events); err != nil {
		// å¦‚æœä½ çš„ç°æœ‰ event è¿˜æ²¡å†™ hashï¼Œå¯åœ¨è¿™é‡Œå…ˆ ComputeChain å†å†™å›å­˜å‚¨ï¼ˆæˆ–ä»…å¯¼å‡ºæ—¶è¡¥é½ï¼‰
		return nil, fmt.Errorf("event chain invalid: %w", err)
	}

	inv, err := ledger.ListToolInvocations(ctx, jobID)
	if err != nil {
		return nil, fmt.Errorf("list ledger: %w", err)
	}

	eventsNDJSON, err := marshalNDJSON(events)
	if err != nil {
		return nil, err
	}
	ledgerNDJSON, err := marshalNDJSON(inv)
	if err != nil {
		return nil, err
	}

	firstHash := events[0].Hash
	lastHash := events[len(events)-1].Hash

	// proof.json
	proofObj := map[string]any{
		"job_id":            jobID,
		"root_hash":         lastHash,
		"chain_validated":   true,
		"ledger_included":   true,
		"generated_by":      "aetheris",
		"schema_version":    "events-chain-v1",
		"runtime_version":   opt.RuntimeVersion,
	}
	proofBytes, _ := json.MarshalIndent(proofObj, "", "  ")

	manifest := NewManifest(jobID, opt.RuntimeVersion, len(events), len(inv), firstHash, lastHash)
	manifest.EventsSHA256 = Sha256Hex(eventsNDJSON)
	manifest.LedgerSHA256 = Sha256Hex(ledgerNDJSON)
	manifest.ProofSHA256 = Sha256Hex(proofBytes)

	manifestBytes, err := manifest.Marshal()
	if err != nil {
		return nil, err
	}

	// zip
	var out bytes.Buffer
	zw := zip.NewWriter(&out)

	if err := writeZipFile(zw, "manifest.json", manifestBytes); err != nil { return nil, err }
	if err := writeZipFile(zw, "events.ndjson", eventsNDJSON); err != nil { return nil, err }
	if err := writeZipFile(zw, "ledger.ndjson", ledgerNDJSON); err != nil { return nil, err }
	if err := writeZipFile(zw, "proof.json", proofBytes); err != nil { return nil, err }

	if err := zw.Close(); err != nil {
		return nil, err
	}
	return out.Bytes(), nil
}

func marshalNDJSON[T any](items []T) ([]byte, error) {
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	for _, it := range items {
		if err := enc.Encode(it); err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func writeZipFile(zw *zip.Writer, name string, content []byte) error {
	f, err := zw.Create(path.Clean(name))
	if err != nil {
		return err
	}
	_, err = io.Copy(f, bytes.NewReader(content))
	return err
}
```

> âš ï¸ æ³¨æ„ï¼šä½ ç›®å‰æ•°æ®åº“é‡Œçš„ events å¯èƒ½è¿˜æ²¡å¸¦ PrevHash/Hashã€‚
> å»ºè®®ç­–ç•¥ï¼š**2.0-M1 å…ˆåœ¨â€œå¯¼å‡ºæ—¶å¼ºåˆ¶é‡ç®—é“¾å¹¶å†™å…¥å¯¼å‡ºåŒ…â€**ï¼ˆä¸ä¸€å®šç«‹å³å†™å› DBï¼‰ï¼Œç­‰åç»­å†è¿ç§»å­˜å‚¨å±‚ã€‚

---

## internal/proof/verify.goï¼ˆç¦»çº¿ verifyï¼‰

```go
package proof

import (
	"archive/zip"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
)

type VerifyResult struct {
	OK     bool
	Errors []string
}

func VerifyEvidenceZip(zipBytes []byte) VerifyResult {
	var res VerifyResult

	zr, err := zip.NewReader(bytes.NewReader(zipBytes), int64(len(zipBytes)))
	if err != nil {
		return fail(res, "open zip: "+err.Error())
	}

	files := map[string][]byte{}
	for _, f := range zr.File {
		rc, err := f.Open()
		if err != nil {
			return fail(res, "open file: "+f.Name+": "+err.Error())
		}
		b, _ := io.ReadAll(rc)
		_ = rc.Close()
		files[f.Name] = b
	}

	manifestBytes, ok := files["manifest.json"]
	if !ok { return fail(res, "missing manifest.json") }
	eventsBytes, ok := files["events.ndjson"]
	if !ok { return fail(res, "missing events.ndjson") }
	ledgerBytes, ok := files["ledger.ndjson"]
	if !ok { return fail(res, "missing ledger.ndjson") }
	proofBytes, ok := files["proof.json"]
	if !ok { return fail(res, "missing proof.json") }

	var m Manifest
	if err := json.Unmarshal(manifestBytes, &m); err != nil {
		return fail(res, "parse manifest: "+err.Error())
	}

	// 1) æ–‡ä»¶ hash æ ¡éªŒ
	if Sha256Hex(eventsBytes) != m.EventsSHA256 {
		res.Errors = append(res.Errors, "events.ndjson sha256 mismatch")
	}
	if Sha256Hex(ledgerBytes) != m.LedgerSHA256 {
		res.Errors = append(res.Errors, "ledger.ndjson sha256 mismatch")
	}
	if Sha256Hex(proofBytes) != m.ProofSHA256 {
		res.Errors = append(res.Errors, "proof.json sha256 mismatch")
	}

	// 2) è§£æ events å¹¶æ ¡éªŒé“¾
	events, err := parseNDJSON[Event](eventsBytes)
	if err != nil {
		return fail(res, "parse events: "+err.Error())
	}
	if len(events) != m.EventCount {
		res.Errors = append(res.Errors, fmt.Sprintf("event_count mismatch: manifest=%d actual=%d", m.EventCount, len(events)))
	}
	if len(events) > 0 {
		if events[0].Hash != m.FirstEventHash {
			res.Errors = append(res.Errors, "first_event_hash mismatch")
		}
		if events[len(events)-1].Hash != m.LastEventHash {
			res.Errors = append(res.Errors, "last_event_hash mismatch")
		}
		if err := ValidateChain(events); err != nil {
			res.Errors = append(res.Errors, "chain invalid: "+err.Error())
		}
	}

	// 3) è§£æ proof.json æ ¡éªŒ root_hash
	var p map[string]any
	_ = json.Unmarshal(proofBytes, &p)
	if rh, _ := p["root_hash"].(string); rh != "" && rh != m.LastEventHash {
		res.Errors = append(res.Errors, "proof.root_hash mismatch with manifest last_event_hash")
	}

	// 4) ledger è§£æ +ï¼ˆå¯é€‰ï¼‰ä¸äº‹ä»¶ä¸­ tool äº‹ä»¶å¯¹é½
	inv, err := parseNDJSON[ToolInvocation](ledgerBytes)
	if err != nil {
		return fail(res, "parse ledger: "+err.Error())
	}
	if len(inv) != m.LedgerCount {
		res.Errors = append(res.Errors, fmt.Sprintf("ledger_count mismatch: manifest=%d actual=%d", m.LedgerCount, len(inv)))
	}

	// TODO: è¿™é‡Œä½ å¯ä»¥åŠ  ValidateLedgerConsistency(events, inv)
	// ä¾‹å¦‚ï¼šç¡®ä¿æ¯ä¸ª tool_invocation_completed åœ¨ ledger é‡Œæœ‰ä¸€æ¡è®°å½•ï¼Œä¸” output hash ä¸€è‡´ã€‚

	res.OK = len(res.Errors) == 0
	return res
}

func parseNDJSON[T any](b []byte) ([]T, error) {
	dec := json.NewDecoder(bytes.NewReader(b))
	var out []T
	for dec.More() {
		var v T
		if err := dec.Decode(&v); err != nil {
			return nil, err
		}
		out = append(out, v)
	}
	return out, nil
}

func fail(res VerifyResult, msg string) VerifyResult {
	res.OK = false
	res.Errors = append(res.Errors, msg)
	return res
}
```

---

## cmd/aetheris/export.goï¼ˆCLI å‘½ä»¤éª¨æ¶ï¼‰

> è¿™é‡Œæˆ‘ä¸çŒœä½ ç”¨ cobra/urfave/flag å“ªä¸ªæ¡†æ¶ã€‚ç»™ä½ ä¸€ä¸ªæœ€é€šç”¨çš„ `flag` è‰å›¾ï¼Œä½ å¯è¿ç§»åˆ°ä½ ç°æœ‰ CLI æ¶æ„é‡Œã€‚

```go
package main

import (
	"context"
	"flag"
	"fmt"
	"os"

	"github.com/fanjia1024/Aetheris/internal/proof"
)

func cmdExport(args []string, js proof.JobStore, ledger proof.Ledger) error {
	fs := flag.NewFlagSet("export", flag.ContinueOnError)
	jobID := fs.String("job", "", "job id")
	out := fs.String("out", "evidence.zip", "output path")
	runtime := fs.String("runtime", "dev", "runtime version label")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *jobID == "" {
		return fmt.Errorf("--job required")
	}

	b, err := proof.ExportEvidenceZip(context.Background(), *jobID, js, ledger, proof.ExportOptions{
		RuntimeVersion: *runtime,
	})
	if err != nil {
		return err
	}

	if err := os.WriteFile(*out, b, 0644); err != nil {
		return err
	}
	fmt.Println("exported:", *out)
	return nil
}
```

---

## cmd/aetheris/verify.goï¼ˆCLI å‘½ä»¤éª¨æ¶ï¼‰

```go
package main

import (
	"flag"
	"fmt"
	"os"

	"github.com/fanjia1024/Aetheris/internal/proof"
)

func cmdVerify(args []string) error {
	fs := flag.NewFlagSet("verify", flag.ContinueOnError)
	in := fs.String("in", "", "evidence zip path")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *in == "" {
		return fmt.Errorf("--in required")
	}

	b, err := os.ReadFile(*in)
	if err != nil {
		return err
	}
	r := proof.VerifyEvidenceZip(b)
	if r.OK {
		fmt.Println("OK")
		return nil
	}
	fmt.Println("FAIL")
	for _, e := range r.Errors {
		fmt.Println(" -", e)
	}
	return fmt.Errorf("verify failed")
}
```

---

## testsï¼šinternal/proof/verify_test.goï¼ˆå››å¤§éªŒæ”¶æµ‹è¯•éª¨æ¶ï¼‰

```go
package proof_test

import (
	"context"
	"encoding/json"
	"testing"
	"time"

	"github.com/fanjia1024/Aetheris/internal/proof"
)

type memJobStore struct{ events []proof.Event }
func (m memJobStore) ListEvents(ctx context.Context, jobID string) ([]proof.Event, error) { return m.events, nil }

type memLedger struct{ inv []proof.ToolInvocation }
func (m memLedger) ListToolInvocations(ctx context.Context, jobID string) ([]proof.ToolInvocation, error) { return m.inv, nil }

func makeEvents(job string, n int) []proof.Event {
	var events []proof.Event
	for i := 0; i < n; i++ {
		p, _ := json.Marshal(map[string]any{"i": i})
		events = append(events, proof.Event{
			ID:        jsonNumber(i),
			JobID:     job,
			Type:      "node_finished",
			Payload:   p,
			Timestamp: time.Unix(1700000000+int64(i), 0).UTC(),
		})
	}
	ev, _ := proof.ComputeChain(events)
	return ev
}

func jsonNumber(i int) string { return json.RawMessage([]byte{}); } // ä½ å¯ä»¥ç›´æ¥ fmt.Sprintf("%d", i)

func TestEvidence_OK(t *testing.T) {
	job := "job_1"
	events := makeEvents(job, 10)
	zipBytes, err := proof.ExportEvidenceZip(context.Background(), job,
		memJobStore{events: events},
		memLedger{inv: []proof.ToolInvocation{}},
		proof.ExportOptions{RuntimeVersion: "test"},
	)
	if err != nil { t.Fatal(err) }

	r := proof.VerifyEvidenceZip(zipBytes)
	if !r.OK {
		t.Fatalf("expected ok, got errors: %+v", r.Errors)
	}
}

func TestEvidence_TamperPayload(t *testing.T) {
	job := "job_1"
	events := makeEvents(job, 10)

	zipBytes, err := proof.ExportEvidenceZip(context.Background(), job,
		memJobStore{events: events},
		memLedger{inv: nil},
		proof.ExportOptions{RuntimeVersion: "test"},
	)
	if err != nil { t.Fatal(err) }

	// ç¯¡æ”¹ï¼šæœ€ç®€å•æ–¹å¼æ˜¯æŠŠ zip è§£å‡ºæ¥æ”¹ events.ndjson å†é‡æ‰“åŒ…ã€‚
	// è¿™é‡Œç»™éª¨æ¶ï¼šä½ å¯ä»¥å†™ä¸€ä¸ª helper ä¿®æ”¹ zip ä¸­æŸä¸ªæ–‡ä»¶å†…å®¹ã€‚
	zipBytes = tamperZipFile(zipBytes, "events.ndjson", func(b []byte) []byte {
		// ä¿®æ”¹ä»»æ„ä¸€è¡Œå­—ç¬¦
		if len(b) > 10 { b[10] ^= 0xFF }
		return b
	})

	r := proof.VerifyEvidenceZip(zipBytes)
	if r.OK {
		t.Fatal("expected verify fail after tamper")
	}
}

func TestEvidence_DeleteMiddleEvent(t *testing.T) {
	job := "job_1"
	events := makeEvents(job, 10)
	zipBytes, err := proof.ExportEvidenceZip(context.Background(), job,
		memJobStore{events: events},
		memLedger{inv: nil},
		proof.ExportOptions{RuntimeVersion: "test"},
	)
	if err != nil { t.Fatal(err) }

	zipBytes = tamperZipFile(zipBytes, "events.ndjson", func(b []byte) []byte {
		// åˆ é™¤ä¸€è¡Œï¼šç²—æš´åšæ³•æŒ‰ '\n' split åˆ é™¤ç¬¬ 5 è¡Œ
		return deleteNDJSONLine(b, 5)
	})

	r := proof.VerifyEvidenceZip(zipBytes)
	if r.OK {
		t.Fatal("expected verify fail after deleting event line")
	}
}

func TestEvidence_LedgerMismatch(t *testing.T) {
	job := "job_1"
	events := makeEvents(job, 10)

	zipBytes, err := proof.ExportEvidenceZip(context.Background(), job,
		memJobStore{events: events},
		memLedger{inv: []proof.ToolInvocation{
			{ID: "1", JobID: job, ToolName: "stripe.charge", Input: json.RawMessage(`{}`), Output: json.RawMessage(`{}`), Status: "ok", Timestamp: time.Now().UTC().Format(time.RFC3339Nano)},
		}},
		proof.ExportOptions{RuntimeVersion: "test"},
	)
	if err != nil { t.Fatal(err) }

	// ä¿®æ”¹ ledger.ndjson ä½†ä¸æ›´æ–° manifest hash
	zipBytes = tamperZipFile(zipBytes, "ledger.ndjson", func(b []byte) []byte {
		if len(b) > 5 { b[5] ^= 0xAA }
		return b
	})

	r := proof.VerifyEvidenceZip(zipBytes)
	if r.OK {
		t.Fatal("expected verify fail after ledger tamper")
	}
}

// ===== helpers (éª¨æ¶) =====
// ä¸‹é¢è¿™äº› helper ä½ å®ç°ä¸€æ¬¡å°±è¡Œï¼šè¯»zip->æ”¹æŸæ–‡ä»¶->å†™å›zip
func tamperZipFile(zipBytes []byte, filename string, mutate func([]byte) []byte) []byte {
	// TODO: å®ç°ï¼šè§£åŒ…->æ›¿æ¢ filename å†…å®¹->é‡æ‰“åŒ…
	return zipBytes
}
func deleteNDJSONLine(b []byte, idx int) []byte {
	// TODO: å®ç°ï¼šæŒ‰ '\n' åˆ†å‰²ã€åˆ é™¤ idx è¡Œï¼ˆæ³¨æ„ç©ºè¡Œï¼‰
	return b
}
```

> è¿™é‡Œ test helper æˆ‘ç•™æˆ TODOï¼Œæ˜¯å› ä¸ºä½  repo é‡Œå¯èƒ½å·²ç»æœ‰ç±»ä¼¼ zip utilï¼›å¦‚æœæ²¡æœ‰ï¼Œæˆ‘ä¹Ÿå¯ä»¥ä¸‹ä¸€æ¡æ¶ˆæ¯æŠŠ helper å®Œæ•´å®ç°å‡ºæ¥ï¼ˆå‡ åè¡Œï¼‰ã€‚

---

# ä½ æ¥ä¸‹æ¥æ€ä¹ˆæ¥å…¥ç°æœ‰ä»£ç ï¼ˆæœ€å…³é”®çš„ä¸¤å¤„ï¼‰

1. **JobStore å¯¹æ¥**
   æŠŠ `proof.JobStore.ListEvents` é€‚é…åˆ°ä½ çœŸå®çš„ `jobstore.JobStore.ListEvents`ã€‚
   å¦‚æœä½ çœŸå®äº‹ä»¶ç»“æ„ä¸æ˜¯æˆ‘è¿™ä¸ª `proof.Event`ï¼Œåšä¸€å±‚è½¬æ¢å°±è¡Œã€‚

2. **Ledger å¯¹æ¥**
   æŠŠ `proof.Ledger.ListToolInvocations` é€‚é…åˆ°ä½ å·²æœ‰çš„ Tool Invocation Ledger / Effect Storeã€‚

---

# ä¸‹ä¸€æ­¥æˆ‘å»ºè®®ä½ ç«‹åˆ»åšçš„æœ€å°è½åœ°é¡ºåºï¼ˆ1 å¤©å†…èƒ½å‡º demoï¼‰

1. å…ˆç”¨å†…å­˜ JobStore/Ledger æŠŠ export/verify è·‘é€š
2. æ¥å…¥çœŸå® JobStoreï¼ˆeventsï¼‰
3. æ¥å…¥çœŸå® Ledgerï¼ˆtool invocationsï¼‰
4. æŠŠ `ValidateLedgerConsistency(events, inv)` è¡¥ä¸Šï¼ˆæˆ‘å¯ä»¥æŒ‰ä½ å½“å‰äº‹ä»¶ç±»å‹å‘½åæ¥å†™å¯¹é½è§„åˆ™ï¼‰

---

å¦‚æœä½ æŠŠ **ä½ å½“å‰çš„äº‹ä»¶ç±»å‹é‡Œä¸ tool ç›¸å…³çš„ event åç§°**ï¼ˆä¾‹å¦‚ `tool_invocation_started/tool_invocation_completed` ä¹‹ç±»ï¼‰è´´ä¸€å°æ®µå‡ºæ¥ï¼Œæˆ‘å°±èƒ½æŠŠ **ValidateLedgerConsistency** ç»™ä½ å†™æˆâ€œä¸¥æ ¼æ ¡éªŒâ€ï¼š

* event é‡Œæ¯ä¸ª invocation_id å¿…é¡»åœ¨ ledger ä¸­å‡ºç°ä¸€æ¬¡
* output hash å¿…é¡»ä¸€è‡´
* çŠ¶æ€æœºå¿…é¡»åˆæ³•ï¼ˆstarted -> completed/failedï¼‰
